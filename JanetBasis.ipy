#%display latex
from delierium.JanetBasis import Autoreduce, Differential_Polynomial, Reorder, CompleteSystem, derivative_to_vec,multipliers
from delierium.MatrixOrder import Context, Mgrlex, Mgrevlex, Mlex
from delierium.helpers import eq
from pprint import pprint
from collections.abc import Iterable
import functools
from operator import mul, sub
from IPython.core.debugger import set_trace
from delierium.helpers import (is_derivative, is_function, eq,
                               order_of_derivative, vector_to_monomial,
                               monomial_to_vector

                               )
from sage.calculus.var import var, function
from sage.calculus.functional import diff


def Lfunc(e):
    return e
def Lcml(e):
    '''Least common left multiply, p.23'''
    return 0
def Lcm(e):
    return 0
def FindIntegrableConditions(S, context):
    monomials = [(_, vector_to_monomial(derivative_to_vec(_.Lder(), context))) for _ in S]
    ms        = tuple ([_[1] for _ in monomials])
    m0 = []
    def map_old_to_new(l):
        # XXX remove
        res = []
        for _l in l:
            res.append (context._independent [vars.index(_l)])
        return res

    # multiplier-collection is our M
    multiplier_collection = []
    for dp, monom in monomials:
        # S1
        _multipliers, _nonmultipliers = multipliers(monom, ms, vars)
        multiplier_collection.append ((dp,
                                       [map_old_to_new([_])[0] for _ in _multipliers],
                                       [map_old_to_new([_])[0] for _ in _nonmultipliers]
                                       ))
    from itertools import product, combinations
    result = []
    for e1, e2 in product(multiplier_collection, repeat=2):
        if e1 == e2: continue
        for m in e1[1]:
            for n in [c for i in range(len(e2[2])+1)
                      for c in combinations(e2[2], i) if c]:
                result.append (e1[0].diff(m) - e2[0].diff(*n))

    return result

def ReduceIntegrabilityConditions(S, context):
    return S
vars = var ("x y")
z = function("z")(*vars)
w = function("w")(*vars)
# ctx: items are in descending order
ctx = Context((w,z), vars, Mgrlex)
f1 =diff(w, y) + x*diff(z,y)/(2*y*(x**2+y)) - w/y
#f1.show()
f2=diff(z,x,y) + y*diff(w,y)/x + 2*y*diff(z, x)/x
#f2.show()
f3 = diff(w, x,y) - 2*x*diff(z, x,2)/y - x*diff(w,x)/y**2
#f3.show()
f4 = diff(w, x,y) + diff(z, x,y) + diff(w, y)/(2*y) - diff(w,x)/y + x* diff(z, y)/y - w/(2*y**2)
f5 =diff(w,y,y) + diff(z,x,y) - diff(w, y)/y + w/(y**2)
#f5.show()
f1dp=Differential_Polynomial(f1, context=ctx)
f2dp=Differential_Polynomial(f2, context=ctx)
f3dp=Differential_Polynomial(f3, context=ctx)
f4dp=Differential_Polynomial(f4, context=ctx)
f5dp=Differential_Polynomial(f5, context=ctx)
class Janet_Basis:
    def __init__ (self, S, context):
        """List of homogenous PDE's + order context"""
        self.S = S
        if not isinstance(self.S, Iterable):
            # bad criterion
            self.S = [self.S]
        self.S = Reorder([Differential_Polynomial(s, context) for s in self.S], context, ascending = True)
        self.S = Autoreduce (self.S, context)
        self.S = CompleteSystem(self.S, context)
        _multipliers = FindIntegrableConditions(self.S, context)
#        for _ in zip (self.S, _multipliers):
#            _[0].show()
#            print(_[1])
        #self.S = ReduceIntegrabilityConditions(self.S, context)
        #if all ([_ == 0 for _ in c]) or not c:
        #    return S\n",
        #S += c\n",
        self.S = Reorder (self.S, context)
    def rank(self):
        return 0
    def order(self):
        return 0
checkS=Janet_Basis([f3,f1,f5, f2,f4], ctx)
for _ in checkS.S:
    _.show()
print(eq.cache_info())
